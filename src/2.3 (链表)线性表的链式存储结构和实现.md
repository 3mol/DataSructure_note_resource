## 链式表

`要做到心中有链`

> 定义:线性表的链式存储称为单链表
>
> 单链表可以解决顺序表需要大量连续的存储空间的缺点,但是单链表需要附加指针域,所以存储密度会降低-->浪费存储空间的缺点.
>
> 由于单链表的元素是离散地分布在存储控件中的,多以单链表是**非随机存取**的存储结构-->即不能直接找到表中某个特定的结点,**寻找某个特点的结点**是,需要**从表头开始以此查找**.
>
>

![1547520992806](F:/OneDrive/Guangdong%20of%20Finance/JAVA/MD%E7%AC%94%E8%AE%B0/assets/1547520992806.png)

### 单链表上基本操作的实现

#### **方法列表**

> ![1547521731071](assets/1547521731071.png)

##### 查找

 1. 按序号

    > **单链表**是一种"顺序存取"的结构，即：为取第 i 元素，首先必须先找到第 i-1 个元素。因此不论 i 值为多少，都必须从头结点开始起数，直数到第 i 个为止。头结点可看成是第1个结点。 
```java
// 读取带头结点单链表中的第i个数据元素
    public Object get(int i) throws Exception {
        Node p = head.next;// 初始化,p指向首结点,j为计数器
        int j = 0;
        while (p != null && j < i) {// 从首结点向后查找，直到p指向第i个元素或p为空
            p = p.next;// 指向后继结点
            ++j;// 计数器的值增1
        }
        if (j > i || p == null) { // i小于0或者大于表长减1
            throw new Exception("第" + i + "个元素不存在");// 输出异常
        }
        return p.data;// 返回元素p
    }
   
```
 2. 按照对象
```java

    // 在带头结点的单链表中查找值为x的元素，如果找到，则函数返回该元素在线性表中的位置，否则返回-1
    public int indexOf(Object x) {
        Node p = head.next;// 初始化,p指向首结点,j为计数器
        int j = 0;
        while (p != null && !p.data.equals(x)) {// 从单链表中的首结点元素开始查找，直到p.data指向元素x或到达单链表的表尾
            p = p.next;// 指向下一个元素
            ++j;// 计数器的值增1
        }
        if (p != null)// 如果p指向表中的某一元素
            return j;// 返回x元素在顺序表中的位置
        else
            return -1;// x元素不在顺序表中
    }
```

##### 插入

在带头结点的单链表的第i个结点之前插入一个数据域值为x的新结点，其中
0≤i≤n 。

```java
    // 在带头结点单链表中第i个数据元素之前插入一个值为x的数据元素
    public void insert(int i, Object x) throws Exception {
        Node p = head;// 初始化p为头结点,j为计数器
        int j = -1; // 第i个结点前驱的位置
        while (p != null && j < i - 1) {// 寻找i个结点的前驱
            p = p.next;
            ++j;// 计数器的值增1
        }
        if (j > i - 1 || p == null) // i不合法
            throw new Exception("插入位置不合理");// 输出异常

        Node s = new Node(x); // 生成新结点
        s.next = p.next;// 插入单链表中
        p.next = s;
    }
```

##### ![1547537967115](assets/1547537967115.png)

> 插入步骤：
>
> 1. 查找到Ai-1的位置（查前驱）
> 2. 创建数据域值为x的新结点
> 3. 修改相关指针地址
>
> **单链表**注意：
>
> 1. i的判断范围是0<=i<=length(). 因为可插入最后一个位置，那个位置就是length
>
> 2. 无需判断链表是否满，因为链表是动态长度的，最大长度由内存决定
>
> 3. 以下的两句不能调换位置！（调换会出现变量覆盖问题）
>
>        s.next = p.next;// 插入单链表中
>        p.next = s;
>
> 4. O(1) 时间就可以完成创建结点和修改链表；但是查找需要从头节点开始查找复杂度O(n)
>
>    -->插入需要查找和插入O(1)+O(n)=O(n)
>
> 5. 有头结点和无头结点在插入时有些不同点：主要表现于插入/删除头结点要把指针指向新结点/第二结点上

##### 删除
删除带头结点单链表中的第i个结点，其中0≤i≤n-1（n为当前链表长度）。

```java
// 将线性表中第i个数据元素删除。其中i取值范围为：0≤i≤length()- 1,如果i值不在此范围则抛出异常
public void remove(int i) throws Exception {
    Node p = head;// p指向要删除结点的前驱结点
    int j = -1;
    while (p.next != null && j < i - 1) {// 寻找i个结点的前驱
        p = p.next;
        ++j;// 计数器的值增1
    }
    if (j > i - 1 || p.next == null) { // i小于0或者大于表长减1
        throw new Exception("删除位置不合理");// 输出异常
    }
    p.next = p.next.next;// 删除结点
}
```

![1547537311454](assets/1547537311454.png)

> 步骤：
>
> 1. 判断是否为空链表
> 2. 查询待删除元素的前驱
> 3. 修改相关链表的指针
>
> 注意
>
> 1. 有头节点无需判断是否为空
> 2. 还是要分有无头节点
>    1. 如果无节点：i=0 时，把指针指向删除元素的后继结点
> 3. 如果查找对象后做删除操作需要增加一个函数。



##### 创建单链表

1. 头插法：插入顺序和真实的顺序相反

2. 尾插法：插入的顺序和真实顺序相同

   > （可以设置尾结点，而无需反复查找最后一位元素然后插入）

##### 查看链表长度

```java
// 求带头结点单链表中的数据元素个数并由函数返回其值
public int length() {
    Node p = head.next;// 初始化,p指向首结点,length为计数器
    int length = 0;
    while (p != null) {// 从首结点向后查找，直到p为空
        p = p.next;// 指向后继结点
        ++length;// 长度增1
    }
    return length;
}
```



## 更多链表

循环链表、双向链表、[循环双向链表]、[静态链表]...

> 由于插入到最后的位置上需要o(n)，通常可以加上一个尾结点指向末尾的元素，以便操作末尾的元素（查找最后一个元素或把元素插入到末尾的位置）
>
> 如果需要经常删除末尾元素呢？找不到尾结点的前驱，如果还是用单链表需要O(n)，这个时候可以用**双向链表**，它可以很方便地找到某一个元素的前驱。这样就可以解决常常以下问题：
>
> 1. 插入到第一位、末位元素
> 2. 删除第一位、末位元素